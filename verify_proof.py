#!/usr/bin/python3

###########################################################################
#  Copyright 2019 Supranational LLC
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
###########################################################################

import hashlib
import random
import sympy

# Size of the small prime
prime_bits = 256

# Update the block hash from an external source
# https://etherscan.io
# eth block 9619000
block_hash = 0x35ffdfc6198abafc21076172b0fb01c4eaf3d15d11a74e6df287ba2694e70b08

proof = {
  # RSA challenge modulus
  "modulus": "25195908475657893494027183240048398571429282126204032027777137836043662020707595556264018525880784406918290641249515082189298559149176184502808489120072844992687392807287776735971418347270261896375014971824691165077613379859095700097330459748808428401797429100642458691817195118746121515172654632282216869987549182422433637259085141865462043576798423387184774447920739934236584823824281198163815010674810451660377306056201619676256133844143603833904414952634432190114657544454178424020924616515723350778707749817125772467962926386356373289912154831438167899885040445364023527381951378636564391212010397122822120720357",

  # Number of iterated squares
  "t": "4044943820224",

  # Small prime
  "l": "62070344150439434270451440225640706144188176978138519340718823654964258204937",

  # Proof value
  "pi": "13671628552571937625129691243676613703293974080158042385027562997077388146167372874103876761535518399838899616735211441671124936294055632253890631026451167319223890907294371765639788827366066885777920540483360926974945857531702456814602698471109609378816858194285565397535670108264918374311282262101536557784494379421210450221956482770952022145796525097711801751672114049668120572935866052610975031125668926944459249287669640134200479829845809649913212908200018990708873219462879842927294903005443019312486305909765999043207950168977920076722235765295646365356226145293797654931207040306390783527604785601984122555049",

  # R, from paper
  "r": "17437056294484704468250034185363099534539823480393288780763672520259588414183",

  # VDF input value (i.e., Eth block hash)
  "g": "24424671406626258651438443984939281088426878021704265060668075761164561615624",

  # Final VDF evaluation value
  "y": "19144252799650690034532093004610517021943100624121228597352889552995687583621339173190502851029907816310407126300686460714009475968112570316274914525310332357507812899123293094648071211640233190710113953260309441777021673998373218670925180551926263064212339548461470232903440429813254769673580307982104275746012049516178273456199635063347683510167860883901215428056724337210897211547353523524300903538679417056679618824614750731361045253660460133221495280406246845045128191812422560355330733281117986696463831747104084345232282788677597701004579630458791913453885010191791670442208877522732218605629867820033633850103",

  # Type of proof
  "type": "1-wesolowski",
}

def sample_prime(g, y, desired_bits):
  l_in = "{:x}*{:x}".format(g, y)
  print("l_in", l_in)
  b = l_in.encode()
  hash = hashlib.sha256(b).digest()
  l = int.from_bytes(hash, byteorder='big')
  
  mask = (1<<desired_bits)-1
  l = l&mask
  
  while not sympy.isprime(l):
    l += 1

  return(l)

modulus = int(proof['modulus'])

# Sample a prime
l = sample_prime(block_hash, int(proof['y']), prime_bits)

# Verify proof
errors = 0
g = block_hash
if int(proof['l']) != l:
  print("ERROR: l does not match")
  errors += 1
  l = int(proof['l'])
    
t = int(proof['t'])
r = int(proof['r'])
y = int(proof['y'])
pi = int(proof['pi'])
  
if pow(2, t, l) != r:
  print("ERROR: r does not match")
  errors += 1

if (pow(pi, l, modulus) * pow(g, r, modulus) % modulus) != y:
  print("ERROR: output does not match")
  errors += 1

if errors == 0:
  print("PASS!")
